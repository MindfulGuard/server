name: CI

on:
  push:
    branches:
      - '*'
      - 'service/**'
    paths-ignore:
      - 'LICENSE'
      - 'README.md'
      - '.gitignore'
      - 'client/**'
      - 'changelog.txt'
      - 'mindfulguard/api/v1/README.md'
      - 'services/configuration/grpc/**'
      - 'build/README.md'
  pull_request:
    branches:
      - '*'
      - 'service/**'
    paths-ignore:
      - 'LICENSE'
      - 'README.md'
      - '.gitignore'
      - 'client/**'
      - 'changelog.txt'
      - 'mindfulguard/api/v1/README.md'
      - 'services/configuration/grpc/**'
      - 'build/README.md'

env:
  CHANGELOG_FILE: changelog.txt
  DEV_BRANCH_NAME: dev
  MAIN_BRANCH_NAME: main
  METAINFO_FILE: metainfo

jobs:
  code_analyzer:
    name: Code Analyzer (Python, PostgreSQL)
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.10
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        architecture: 'x64'
    
    - name: Dependency installation
      run: |
        pip install pylint sqlfluff
        make bootstrap

    - name: Starting the analyzer (Python)
      run: pylint --rcfile=.github/configs/pylintrc.ini setup.py mindfulguard tests routines
      continue-on-error: true

    - name: Starting the analyzer (PostgreSQL)
      run: sqlfluff lint --config .github/configs/sqlfluff.toml db/migrations/*.sql
      continue-on-error: true

  test:
    name: Test of the main branches (main & dev)
    if: ${{(startsWith(github.ref, 'refs/heads/main') || startsWith(github.ref, 'refs/heads/dev'))}}
    runs-on: ubuntu-latest

    env:
      CONFIG_ENV_FILE: docker/.SERVER.env
      DYNAMIC_CONFIGURATIONS_SERVICE_PATH: services/dynamic_configurations

      admin_login: UserADmin12345_-
      admin_password: AdminPassword_-4234__-43223
      POSTGRES_PORT: 5432
      POSTGRES_HOST: localhost
      POSTGRES_DB: mindfulguard_production
      POSTGRES_USER: mindfulguard
      POSTGRES_PASSWORD: root_password
      MINIO_HOSTNAME: http://localhost:9000
      MINIO_ROOT_USER: rootuser123
      MINIO_ROOT_PASSWORD: rootpassword123
      MINIO_USER_ACCESS_KEY: useruser123
      MINIO_USER_SECRET_KEY: userpassword123
      REDIS_PASSWORD: userpassword
      REDIS_ARGS: --loglevel warning --requirepass ${REDIS_PASSWORD}
      REDIS_HOST: localhost
      REDIS_PORT: 6379
      REDIS_USERNAME: default
      REDIS_LD: 0
      MINDFULGUARD_ARGS: --LOG-LEVEL TRACE --LOG-TO-CONSOLE
      SERVICE_DYNAMIC_CONFIGURATIONS_HOST: localhost:9001
      DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID: NONE
      DYNAMIC_CONFIGURATIONS_CONSUL_HOST: localhost:8500
      
    steps:
      - uses: actions/checkout@v4

      - name: Writing variables to a file
        run: |
          echo "" > ${{env.CONFIG_ENV_FILE}}

          cat <<EOF > docker/.SERVER.env
          POSTGRES_PORT=${{env.POSTGRES_PORT}}
          POSTGRES_HOST=${{env.POSTGRES_HOST}}
          POSTGRES_DB=${{env.POSTGRES_DB}}
          POSTGRES_USER=${{env.POSTGRES_USER}}
          POSTGRES_PASSWORD=${{env.POSTGRES_PASSWORD}}
          MINIO_HOSTNAME=${{env.MINIO_HOSTNAME}}
          MINIO_ROOT_USER=${{env.MINIO_ROOT_USER}}
          MINIO_ROOT_PASSWORD=${{env.MINIO_ROOT_PASSWORD}}
          MINIO_USER_ACCESS_KEY=${{env.MINIO_USER_ACCESS_KEY}}
          MINIO_USER_SECRET_KEY=${{env.MINIO_USER_SECRET_KEY}}
          REDIS_PASSWORD=${{env.REDIS_PASSWORD}}
          REDIS_ARGS="${{env.REDIS_ARGS}}"
          REDIS_HOST=${{env.REDIS_HOST}}
          REDIS_PORT=${{env.REDIS_PORT}}
          REDIS_USERNAME=${{env.REDIS_USERNAME}}
          REDIS_LD=${{env.REDIS_LD}}
          MINDFULGUARD_ARGS="${{env.MINDFULGUARD_ARGS}}"
          SERVICE_DYNAMIC_CONFIGURATIONS_HOST=${{env.SERVICE_DYNAMIC_CONFIGURATIONS_HOST}}
          DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID=${{env.DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID}}
          DYNAMIC_CONFIGURATIONS_CONSUL_HOST=${{env.DYNAMIC_CONFIGURATIONS_CONSUL_HOST}}
          EOF

      - name: Run Services
        run: | 
          docker-compose -f ./docker/docker-compose-dev.yml up -d
          sleep 30

      - name: Install Migrate
        run: |
          sudo apt-get update

          curl -sSL https://github.com/golang-migrate/migrate/releases/download/v4.17.0/migrate.linux-amd64.deb \
          --create-dirs -o /home/$USER/migrate.linux-amd64.deb && sudo dpkg -i /home/$USER/migrate.linux-amd64.deb

      - name: Database Initialization
        run: make migration-up
        env:
          POSTGRES_USER: ${{env.POSTGRES_USER}}
          POSTGRES_PASSWORD: ${{env.POSTGRES_PASSWORD}}
          POSTGRES_HOST: ${{env.POSTGRES_HOST}}
          POSTGRES_PORT: ${{env.POSTGRES_PORT}}
          POSTGRES_DB: ${{env.POSTGRES_DB}}

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          architecture: 'x64'
      - run: python -c "import sys; print(sys.version)"

      - uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      - run: go version

      - name: Installing dependencies
        run: |
          python -m pip install --upgrade pip
          make bootstrap

      - name: Check if MinIO is running
        run: |
          timeout=15
          while ! curl http://localhost:9000 && [ $timeout -gt 0 ]; do
            echo "Waiting for MinIO to start..."
            sleep 5
            timeout=$((timeout-5))
          done
        
          if [ $timeout -le 0 ]; then
            echo "MinIO did not start within the specified timeout."
            exit 1
          fi

      - name: Initialize the administrator
        run: |
          make -f build/Makefile init \
            admin_login="${{ env.admin_login }}" \
            admin_password="${{ env.admin_password }}" \
            database_host="${{env.POSTGRES_HOST}}" \
            database_name="${{ env.POSTGRES_DB }}" \
            database_port="${{env.POSTGRES_PORT}}" \
            database_user="${{ env.POSTGRES_USER }}" \
            database_password="${{ env.POSTGRES_PASSWORD }}" \
            minio_hostname="${{ env.MINIO_HOSTNAME }}" \
            minio_root_access_key="${{ env.MINIO_ROOT_USER }}" \
            minio_root_secret_key="${{ env.MINIO_ROOT_PASSWORD }}" \
            minio_user_access_key="${{ env.MINIO_USER_ACCESS_KEY }}" \
            minio_user_secret_key="${{ env.MINIO_USER_SECRET_KEY }}"
      
      - name: Build service "Dynamic configurations"
        run: |
          cd ${{env.DYNAMIC_CONFIGURATIONS_SERVICE_PATH}}
          make build

      - name: Running Tests
        run: |
          ./${{env.DYNAMIC_CONFIGURATIONS_SERVICE_PATH}}/build/dynamic_configurations -LOG-LEVEL DEBUG &
          make test
        env:
          POSTGRES_HOST: ${{env.POSTGRES_HOST}}
          POSTGRES_PORT: ${{env.POSTGRES_PORT}}
          POSTGRES_DB: ${{env.POSTGRES_DB}}
          POSTGRES_USER: ${{env.POSTGRES_USER}}
          POSTGRES_PASSWORD: ${{env.POSTGRES_PASSWORD}}
          MINIO_HOSTNAME: ${{env.MINIO_HOSTNAME}}
          MINIO_ROOT_USER: ${{env.MINIO_ROOT_USER}}
          MINIO_ROOT_PASSWORD: ${{env.MINIO_ROOT_PASSWORD}}
          MINIO_USER_ACCESS_KEY: ${{env.MINIO_USER_ACCESS_KEY}}
          MINIO_USER_SECRET_KEY: ${{env.MINIO_USER_SECRET_KEY}}
          REDIS_PASSWORD: ${{env.REDIS_PASSWORD}}
          REDIS_HOST: ${{env.REDIS_HOST}}
          REDIS_PORT: ${{env.REDIS_PORT}}
          REDIS_USERNAME: ${{env.REDIS_USERNAME}}
          REDIS_LD: ${{env.REDIS_LD}}
          MINDFULGUARD_ARGS: ${{env.MINDFULGUARD_ARGS}}
          SERVICE_DYNAMIC_CONFIGURATIONS_HOST: ${{env.SERVICE_DYNAMIC_CONFIGURATIONS_HOST}}
          DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID: ${{env.DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID}}
          DYNAMIC_CONFIGURATIONS_CONSUL_HOST: ${{env.DYNAMIC_CONFIGURATIONS_CONSUL_HOST}}
      
      - name: Copying logs
        run: |
          mkdir test_logs
          cp -r tests/.logs/* test_logs/

      - uses: actions/upload-artifact@v4
        with:
          name: test-logs
          path: test_logs

  test_service_dynamic_configurations:
    name: Test Service "Dynamic configurations"
    if: ${{startsWith(github.ref, 'refs/heads/service/dynamic_configurations')}}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.20', '1.21', '1.22']
      
    env:
      SERVICE_NAME: dynamic_configurations
      SERVICE_PATH: services/dynamic_configurations
      DYNAMIC_CONFIGURATIONS_CONSUL_HOST: localhost:8500

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Consul CLI
        run: |
          curl -Lo consul.zip https://releases.hashicorp.com/consul/1.18.0/consul_1.18.0_linux_amd64.zip
          unzip consul.zip -d /usr/local/bin
          consul --version

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          jq --version

      - name: Start Consul dev server
        run: |
          consul agent -dev -bind=127.0.0.1 &

      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Unit Test
        run: |
          cd ${{env.SERVICE_PATH}}
          make test
        env:
          DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID: "NONE"
          DYNAMIC_CONFIGURATIONS_CONSUL_HOST: ${{env.DYNAMIC_CONFIGURATIONS_CONSUL_HOST}}

      - name: Server Test
        run: |
          cd ${{env.SERVICE_PATH}}
          make build
          make test-grpc
        env:
          DYNAMIC_CONFIGURATIONS_CONSUL_SECRET_ID: "NONE"
          DYNAMIC_CONFIGURATIONS_CONSUL_HOST: ${{env.DYNAMIC_CONFIGURATIONS_CONSUL_HOST}}
        timeout-minutes: 5
  
  docker:
    name: Docker
    needs: test
    runs-on: ubuntu-latest
    if: ${{ needs.test.result == 'success' && (startsWith(github.ref, 'refs/heads/main') || startsWith(github.ref, 'refs/heads/dev'))}}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get meta-information
        run: |
          source ${{env.METAINFO_FILE}}
          echo "APP_VERSION=${APP_VERSION}" >> $GITHUB_ENV
          echo "APP_VERSION_RELEASE=${APP_VERSION_RELEASE}" >> $GITHUB_ENV
          echo "APP_PUBLISH_RELEASE=${APP_PUBLISH_RELEASE}" >> $GITHUB_ENV
        
      - name: Release Permission Check
        run: |
          if [[ "${{ env.APP_PUBLISH_RELEASE }}" = "false" ]]; then
            if [[ "${{ github.ref }}" = "refs/heads/${{ env.MAIN_BRANCH_NAME }}" ]]; then
              echo "Attention, the code in the ${{ env.MAIN_BRANCH_NAME }} branch must necessarily be published to releases!";
              exit 1;
            else
              echo "The release publication has been canceled!";
              exit 1;
            fi
          fi

          if [[ "${{ github.ref }}" = "refs/heads/${{ env.MAIN_BRANCH_NAME }}" && "${{ env.APP_VERSION_RELEASE }}" = "false" ]]; then
            echo "The ${{ env.MAIN_BRANCH_NAME }} branch cannot be used for non-release versions!";
            exit 1;
          fi

          if [[ "${{ github.ref }}" = "refs/heads/${{ env.DEV_BRANCH_NAME }}" && "${{ env.APP_VERSION_RELEASE }}" = "true" ]]; then
            echo "Use the ${{ env.MAIN_BRANCH_NAME }} branch for the release build!";
            exit 1;
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Updating
        run: |
          sudo apt-get update

      - name: Login to GitHub Container Registry
        run: echo ${{ secrets.ACTIONS }} | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
      
      - name: Convert repository owner to lowercase
        id: repo_nameLC
        run: |
          echo "variable=${{ github.repository }}" | tr '[:upper:]' '[:lower:]' >> "$GITHUB_OUTPUT" 

      - name: Get information about the latest version
        run: |
          is_dev=""
          echo "TAG_NAME=${{env.APP_VERSION}}" >> $GITHUB_ENV
          if [[ "${{ github.ref }}" = "refs/heads/${{ env.DEV_BRANCH_NAME }}" ]]; then
            is_dev="-${{ env.DEV_BRANCH_NAME }}"
          fi
          echo "is_dev=${is_dev}" >> $GITHUB_ENV

      - name: Build and Push Docker Container
        run: |
          docker buildx build --push --platform linux/amd64 -t ghcr.io/${{ steps.repo_nameLC.outputs.variable }}:${TAG_NAME}${{env.is_dev}} .

  release:
    name: Create Release
    needs: docker
    runs-on: ubuntu-latest
    if: ${{ needs.docker.result == 'success' }}

    steps:
    - name: Check out code
      uses: actions/checkout@v4

    - name: Get meta-information
      run: |
        source ${{env.METAINFO_FILE}}
        echo "APP_VERSION=${APP_VERSION}" >> $GITHUB_ENV
        echo "APP_VERSION_RELEASE=${APP_VERSION_RELEASE}" >> $GITHUB_ENV

    - name: Get Change log
      run: |
        sudo chmod +x .ci/get_changelog.sh
        ./.ci/get_changelog.sh ${{env.CHANGELOG_FILE}} ${{env.APP_VERSION}} > ${{ env.CHANGELOG_FILE }}.tmp

    - name: Get the latest version
      run: |
        echo "PRERELEASE=false" >> $GITHUB_ENV
        echo "TAG_NAME=${{ env.APP_VERSION }}" >> $GITHUB_ENV

        if [[ "${{ github.ref }}" = "refs/heads/${{ env.DEV_BRANCH_NAME }}" && "${{ env.APP_VERSION_RELEASE }}" = "false" ]]; then
          echo "PRERELEASE=true" >> $GITHUB_ENV;
        fi

    - name: Create release directory
      run: |
        mkdir build-release
        cp -r build build-release/
        cp -r docker build-release/
        tar -czvf build-release.tar.gz build-release
      working-directory: ${{ github.workspace }}

    - name: Create GitHub Release
      id: create_release
      uses: softprops/action-gh-release@v2
      with:
        body_path: ${{ env.CHANGELOG_FILE }}.tmp
        files: build-release.tar.gz
        tag_name: ${{env.TAG_NAME}}
        prerelease: ${{env.PRERELEASE}}
      env:
        GITHUB_TOKEN: ${{ secrets.ACTIONS }}
